<resources>
    <string name="first_intro">Visualization of the Olympiad algorithms</string>
    <string name="app_name">VisuAlgOl</string>
    <string name="about">Welcome to VisuAlgOl! This application was created to learn olympiad algorithms in informatics with the support of the HSE Lyceum. To continue, click the button below.</string>
    <string name="go_next">Go</string>
    <string name="choose">Choose an algorithm</string>

    <string name="sorting">Sorting algorithms</string>
    <string name="sort">Sort</string>
    <string name="sort_intro">Sorting</string>
    <string name="stupid_sort">Stupid sort</string>
    <string name="bubble_sort">Bubble sort</string>
    <string name="selection_sort">Selection sort</string>
    <string name="insertion_sort">Insertion sort</string>
    <string name="merge_sort">Merge sort</string>
    <string name="quick_sort">Quick sort</string>
    <string name="counting_sort">Counting sort</string>
    <string name="radix_sort">Radix sort</string>

    <string name="search">Search algorithms</string>
    <string name="lin_search">Linear search</string>
    <string name="bin_search">Binary search</string>
    <string name="ter_search">Ternary search</string>

    <string name="recursion">Recursion</string>

    <string name="graphs">Graphs</string>
    <string name="dfs">DFS</string>
    <string name="bfs">BFS</string>

    <string name="strings">Strings</string>
    <string name="prefix">Prefix-function</string>
    <string name="z">Z-function</string>

    <string name="data_structures">Data structures</string>
    <string name="st">Segment Tree</string>
    <string name="bst">BST</string>

    <string name="what">What is it and what is it for?</string>

    <string name="whatIsSort">What is sorting?</string>
    <string name="sort_introduction">Sorting is ordering: arranging items in a sequence ordered by some criterion. For example, people at school in pe lessons and in the army are lined up by height, because the order is needed.</string>
    <string name="soldiers">Soldiers lined up in a row</string>
    <string name="sort_stupid">The simplest low-efficiency sorting training algorithm is presented above: it goes through the desired array, compares neighboring elements and, if the order in their pair is incorrect, changes them and returns to the beginning of the array, after which it repeats all the same actions. The algorithm terminates if it does not find any unsorted pairs during the complete traversal.</string>

    <string name="sort_bub">Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.</string>

    <string name="sort_sel">Selection sort is a simple sorting algorithm that traverses the array from beginning to end, at each i-th step finds the i-th minimum element using a linear search and swaps it with the first element in the unsorted part of the array (the i-th element). This will result in an array sorted in non-descending order.</string>

    <string name="sort_ins">Insertion sort is a sorting algorithm in which the elements of the input sequence are scanned one at a time, and each new incoming element is placed in a suitable place among the previously sorted elements using a linear search.</string>

    <string name="sort_mer">Merge sort is a sorting algorithm that uses the "divide and conquer" principle: the problem is divided into several smaller subproblems, which are solved separately, after which their solutions are combined to obtain a solution to the original problem. Specifically, the merge sort procedure can be described as follows:\n1. If the array under consideration has one element, then it has already been sorted — the algorithm terminates.\n2. Otherwise, the array is split into two parts, which are sorted recursively.\n3. After sorting the two parts of the array, the merge procedure is applied to them, which, using the two sorted parts, gets the original sorted array.</string>

    <string name="sort_q">Quicksort is a sorting algorithm that uses the “divide and conquer” principle: the problem is divided into several smaller subproblems, which are solved separately, after which their solutions are combined to obtain a solution to the original problem. Specifically, the quicksort procedure can be described as follows:\n1. The pivot element is selected in the array.\n2. All other elements are compared with the reference and rearranged in the array so as to split the array into three continuous segments following one after another: “less than the reference”, “equal” and “greater”\n3. Segments of "smaller" and "larger" values are sorted using a recursive quicksort call if their length is greater than one.\n4. Since they are sorted in place, no action is required to merge them: the entire array is sorted.</string>

    <string name="sort_cou">Counting sort is a sorting algorithm that uses a range of integers in the array being sorted to count matching elements. The use of counting sort is useful only when the sorted numbers have a range of possible values that is small enough compared to the set being sorted. Specifically, the quicksort procedure can be described as follows: lets create an array of size r - l, where l is the minimum and r is the maximum element of the array. After that, we go through the desired array and count the number of occurrences of each element. Now we can iterate through the array of values and write out each number as many times as needed.</string>

    <string name="lin_s">Linear search is an algorithm for finding a given value of an arbitrary function (including the value of an array) on a certain segment, carried out by successively comparing the next value under consideration with the desired one until these values coincide (with one or another accuracy). This algorithm is the simplest search algorithm and, unlike, for example, binary search, does not impose any restrictions on the function and has the simplest implementation.</string>

    <string name="bin_s">Binary search is an algorithm for finding the value of a sorted array, carried out by splitting the array into halves. Its procedure can be described as follows:\n We determine the value of the element in the middle, between the boundaries, and compare it with the desired one. If the search value is greater than the middle value, then we narrow the search area so that the new left border is equal to the index of the middle of the previous area. Otherwise, assign this value to the right border. We continue this procedure until the right border is greater than the left by more than 1.</string>

    <string name="dfs_">Depth-first search is one of the main graph search methods and is the basis for many important algorithms for working with graphs. Depth-first traversal, as the name suggests, goes "deep" into the graph as far as possible. The algorithm for this traversal is described recursively: we go through all the edges outgoing from the considered vertex. If the edge leads to a vertex that was not considered earlier, then we run the algorithm from this unconsidered vertex, and then we return and continue to iterate through the edges. The return occurs only if there are no edges left in the considered vertex that lead to the unexamined vertex. If, after the completion of the algorithm, not all vertices have been considered, then it is necessary to start the algorithm from one of the unconsidered vertices.</string>

    <string name="bfs_">Breadth-first search is one of the main graph search methods and is the basis for many important algorithms for working with graphs. Breadth crawl, as the name implies, "expands" as much as possible. The algorithm for this traversal is described as follows: we go through all the edges outgoing from the considered vertex. If the edge leads to a vertex that has not been considered before, then we put this vertex in the queue. After we have gone through all the edges outgoing from the vertex, we start the algorithm from the first vertex in the queue.</string>

    <string name="prefix_fun">The prefix function is the length of the largest prefix of a string, which is also its suffix. Lets define a prefix function from string s at position i as follows:\n π(s,i) = max {k ∣ s[0…k] = s[i−k…i]}.</string>

    <string name="z_fun">The z-function is the length of the largest prefix of the substring starting at position x in the string s, which is also the prefix of the entire string. Define the z-function of the string s as follows:\n z[i](s) = max {k ∣ s[i…i+k] = s[0…k]}.</string>

    <string name="s_t">A segment tree is a data structure that allows you to quickly change values in an array and find some functions from some subsegment a[l]…a[r] of the original array.</string>

    <string name="b_s_t">Binary search tree is a data structure for working with ordered sets. A binary search tree has the following property: if x is a node of a binary tree with key k, then all nodes in the left subtree must have keys less than k, and those in the right subtree must have keys greater than k.</string>

    <string name="basic_sort2">.....................</string>
    <string name="generate">Generate</string>
    <string name="run">Run</string>
    <string name="nothingToShow">.....................</string>
    <string name="one">1</string>
    <string name="symbol">a</string>
    <string name="answer">Answer:</string>
    <string name="check">Check</string>
    <string name="task">Task</string>
    <string name="sec">1.25 sec</string>
    <string name="construction">Construction</string>
    <string name="sum">Sum</string>
    <string name="insertion">Insertion</string>
    <string name="deletion">Deletion</string>

    <string name="task1">Sort the following array of numbers in ascending order: 2 1 3</string>
    <string name="task2">Determine how many swaps the ascending bubble sort algorithm will do for the given array:\n4 1 5 3</string>
    <string name="task3">Determine what the following array will look like after two selection sort exchanges:\n4 1 2 3</string>
    <string name="task4">Determine what the following array will look like after two insertion sort exchanges:\n4 3 2 1</string>
    <string name="task5">Determine what the following array will look like after two merge sort operations:\n4 1 3 4 5 6 4 5</string>
    <string name="task6">Determine what the following array will look like after one quicksort exchange:\n4 3 2 1</string>
    <string name="task7">Determine how many steps the counting sort algorithm will take to sort the following array:\n1 2 4 6</string>
    <string name="task8">Determine how many steps it takes to linear search in array\n7 2 5 1 8 4 3 8\nfind an element\n8</string>
    <string name="task9">Determine how many steps it takes to binary search in array\n1 2 3 4 5 6 7 8\nfind an element\n8</string>
    <string name="task10">Determine how many vertices will be visited by depth-first search in the graph in the figure from vertex 8 before vertex 5</string>
    <string name="task11">Determine how many vertices will be visited by breadth-first search in the graph in the figure from vertex 8 before vertex 5</string>
    <string name="task12">What will the prefix function look like from the string abacaba at position 6 (numbering from 0)</string>
    <string name="task13">What will the z-function look like from the string abacaba at position 6 (numbered from 0)</string>
    <string name="previous">previous stage</string>
    <string name="stage">stage</string>
    <string name="next">next stage</string>
</resources>